<!DOCTYPE html>
<!-- taken from https://github.com/jgm/pandoc-templates/blob/05d510b4dc5af87cbf25d92fa8318f44e155b919/default.html5 -->
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2020-06-29" />
  <title>Encypted Btrfs Root with Opt-in State on NixOS</title>
  <link rel="stylesheet" href="/blog/static/normalize.css" />
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="/blog/static/custom.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div id="navigation-bar">
  <div id="navigation-content">
    <a href="../index.html">index</a>
  </div>
</div>
<article>
<header id="title-block-header">
<h1 class="title">Encypted Btrfs Root with Opt-in State on NixOS</h1>
<p class="date">2020-06-29</p>
<p class="category">category: <a href="../category/tech.html">tech</a></p>
<p class="category">
tags: <a href="../tag/NixOS.html">NixOS</a> 
</p>
</header>
<p><a href="https://grahamc.com/blog/erase-your-darlings">grahamc’s “Erase your darlings” blog post</a> is an amazing example of what a snapshotting filesystems (zfs) combined with an immutable, infrastructue-as-code OS (NixOS) can achieve. To summarize the post, grahamc demonstrates how to erase the root partition at boot while opting in to state by getting NixOS to symlink stuff to a dedicated partition. This restores the machine to a clean state on every boot, preserving the “new computer smell”.</p>
<p>I believe the main selling point of this concept of <strong>opt-in state</strong> is that it makes it dead simple to keep track of ephemeral machine state (everything not explicitly specified by your NixOS configuration) and enforces elimination of <a href="https://dzone.com/articles/configuration-drift">Configuration Drift</a>. While the benefits of this are clear for servers, this also works pretty well with workstations and laptops, where you gradually accumulate junk in <code>/etc</code> and <code>/var</code> which you never can be completely confident in deleting.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>Here are some notes on how to reproduce the setup with an encrypted<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> btrfs root, along with a few tips for a nicer laptop experience. The instructions for encrypted btrfs root are heavily based on <a href="https://jappieklooster.nl/nixos-on-encrypted-btrfs.html">this blog post</a>.</p>
<h2 id="making-a-live-usb">Making a Live USB</h2>
<p>The laptop I’m currently using is a Dell XPS-13 2-in-1 (7390) with <a href="https://wiki.archlinux.org/index.php/Dell_XPS_13_2-in-1_(7390)">a fair number of issues running on Linux</a>, some of which interferes with boot. Fortunately, most of these have been fixed in newer kernels, but the default installation ISO ships an older kernel version, so we need a custom ISO. Building an ISO with a custom configuration for NixOS is shockingly simple; following the instructions on the <a href="https://nixos.wiki/wiki/Creating_a_NixOS_live_CD">wiki</a>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co"># iso.nix</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">{</span> <span class="ex">config</span>, pkgs, ... <span class="kw">}</span>:</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="kw">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>  <span class="ex">imports</span> = [</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="co"># installation-cd-graphical-plasma5-new-kernel.nix uses pkgs.linuxPackages_latest</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    <span class="co"># instead of the default kernel.</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>    <span class="op">&lt;</span><span class="ex">nixpkgs/nixos/modules/installer/cd-dvd</span>/<span class="ex">installation-cd-graphical-plasma5-new-kernel.nix</span><span class="op">&gt;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>    <span class="op">&lt;</span><span class="ex">nixpkgs/nixos/modules/installer/cd-dvd</span>/<span class="ex">channel.nix</span><span class="op">&gt;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>  ];</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>  <span class="ex">hardware.enableAllFirmware</span> = true<span class="kw">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>  <span class="ex">nixpkgs.config.allowUnfree</span> = true<span class="kw">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>  <span class="ex">environment.systemPackages</span> = with pkgs<span class="kw">;</span><span class="bu"> [</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a>    wget</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a>    vim</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>    git</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a>    tmux</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a>    gparted</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a>    nix-prefetch-scripts</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a>  ];</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a>}</span></code></pre></div>
<p>The image can be built with</p>
<pre><code>nix-build &#39;&lt;nixpkgs/nixos&gt;&#39; -A config.system.build.isoImage -I nixos-config=iso.nix</code></pre>
<p>Then, we write the ISO to a USB stick like so:</p>
<pre><code>sudo dd if=./result/iso/nixos-20.03....-x86_64-linux.iso of=/dev/&lt;usb device&gt; bs=1M status=progress</code></pre>
<h2 id="nixos-installation">NixOS Installation</h2>
<p>Once we’ve booted into a graphical session, we need to partition the disk. We’ll refer to the whole disk as <code>$DISK</code> (<code>/dev/nvme0n1</code> in my case), and we need three partitions. The EFI partition, swap<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, and the rest of the disk for btrfs to use, which we’ll respecively refer to as <code>"$DISK"p1</code>, <code>"$DISK"p2</code>, and <code>"$DISK"p3</code>.</p>
<p>Btrfs doesn’t natively support encryption, so we’ll be using <a href="https://wiki.archlinux.org/index.php/Dm-crypt">dm-crypt</a> to transparently encrypt the partition, which would be available at <code>/dev/mapper/enc</code> after running these commands:</p>
<pre><code>cryptsetup --verify-passphrase -v luksFormat &quot;$DISK&quot;p3
cryptsetup open &quot;$DISK&quot;p3 enc</code></pre>
<p>We can then format each partition as needed:</p>
<pre><code>mkfs.vfat -n boot &quot;$DISK&quot;p1
mkswap &quot;$DISK&quot;p2
swapon &quot;$DISK&quot;p2
mkfs.btrfs /dev/mapper/enc</code></pre>
<p>Now we have a btrfs volume, we need to decide on how to structure our subvolumes. We want to split our data into a number of subvolumes to keep track of a few things:</p>
<ul>
<li>root: The subvolume for <code>/</code>, which will be cleared on every boot.</li>
<li>home: The subvolume for <code>/home</code>, which should be backed up.</li>
<li>nix: The subvolume for <code>/nix</code>, which needs to be persistent but is not worth backing up, as it’s trivial to reconstruct.</li>
<li>persist: The subvolume for <code>/persist</code>, containing system state which should be persistent across reboots and possibly backed up.</li>
<li>log: The subvolume for <code>/var/log</code>. I’m not so interested in backing up logs but I want them to be preserved across reboots, so I’m dedicating a subvolume to logs rather than using the persist subvolume.</li>
</ul>
<p>Somewhat arbitrarily, we’ll go with the <a href="https://btrfs.wiki.kernel.org/index.php/SysadminGuide#Flat">“Flat” layout as described in the btrfs wiki</a>, and create our subvolumes accordingly.</p>
<pre><code>mount -t btrfs /dev/mapper/enc /mnt

# We first create the subvolumes outlined above:
btrfs subvolume create /mnt/root
btrfs subvolume create /mnt/home
btrfs subvolume create /mnt/nix
btrfs subvolume create /mnt/persist
btrfs subvolume create /mnt/log

# We then take an empty *readonly* snapshot of the root subvolume,
# which we&#39;ll eventually rollback to on every boot.
btrfs subvolume snapshot -r /mnt/root /mnt/root-blank

umount /mnt</code></pre>
<p>Once we’ve created the subvolumes, we mount them with the options that we want. Here, we’re using <a href="https://facebook.github.io/zstd/">Zstandard compression</a> along with the <code>noatime</code> option.</p>
<pre><code>mount -o subvol=root,compress=zstd,noatime /dev/mapper/enc /mnt

mkdir /mnt/home
mount -o subvol=home,compress=zstd,noatime /dev/mapper/enc /mnt/home

mkdir /mnt/nix
mount -o subvol=nix,compress=zstd,noatime /dev/mapper/enc /mnt/nix

mkdir /mnt/persist
mount -o subvol=persist,compress=zstd,noatime /dev/mapper/enc /mnt/persist

mkdir -p /mnt/var/log
mount -o subvol=log,compress=zstd,noatime /dev/mapper/enc /mnt/var/log

# don&#39;t forget this!
mkdir /mnt/boot
mount &quot;$DISK&quot;p1 /mnt/boot</code></pre>
<p>Then, let NixOS figure out the config.</p>
<pre><code>nixos-generate-config --root /mnt</code></pre>
<p>This should result with <code>/mnt/etc/nixos/hardware-configuration.nix</code> looking something like this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="co"># Do not modify this file!  It was generated by ‘nixos-generate-config’</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="co"># and may be overwritten by future invocations.  Please make changes</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span class="co"># to /etc/nixos/configuration.nix instead.</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="kw">{</span> <span class="ex">config</span>, lib, pkgs, ... <span class="kw">}</span>:</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a><span class="kw">{</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>  <span class="ex">imports</span> =</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>    [ <span class="op">&lt;</span><span class="ex">nixpkgs/nixos/modules/installer/scan</span>/<span class="ex">not-detected.nix</span><span class="op">&gt;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>    ];</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>  <span class="ex">boot.initrd.availableKernelModules</span> = [ <span class="st">&quot;xhci_pci&quot;</span> <span class="st">&quot;nvme&quot;</span> <span class="st">&quot;usb_storage&quot;</span> <span class="st">&quot;sd_mod&quot;</span> <span class="st">&quot;rtsx_pci_sdmmc&quot;</span> ]<span class="kw">;</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>  <span class="ex">boot.initrd.kernelModules</span> = [ ]<span class="kw">;</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a>  <span class="ex">boot.kernelModules</span> = [ <span class="st">&quot;kvm-intel&quot;</span> ]<span class="kw">;</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a>  <span class="ex">boot.extraModulePackages</span> = [ ]<span class="kw">;</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true"></a>  <span class="ex">fileSystems.</span><span class="st">&quot;/&quot;</span> =</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true"></a>    <span class="kw">{</span> <span class="ex">device</span> = <span class="st">&quot;/dev/disk/by-uuid/f73c53b7-ae6c-4240-89c3-511ad918edcc&quot;</span><span class="kw">;</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true"></a>      <span class="ex">fsType</span> = <span class="st">&quot;btrfs&quot;</span><span class="kw">;</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true"></a>      <span class="ex">options</span> = [ <span class="st">&quot;subvol=root&quot;</span> <span class="st">&quot;compress=zstd&quot;</span> <span class="st">&quot;noatime&quot;</span> ]<span class="kw">;</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true"></a>    <span class="kw">}</span>;</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true"></a></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true"></a>  <span class="ex">boot.initrd.luks.devices.</span><span class="st">&quot;enc&quot;</span>.device = <span class="st">&quot;/dev/disk/by-uuid/050db9bf-0741-4150-8cf8-d6ec12735d4c&quot;</span><span class="kw">;</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true"></a></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true"></a>  <span class="ex">fileSystems.</span><span class="st">&quot;/home&quot;</span> =</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true"></a>    <span class="kw">{</span> <span class="ex">device</span> = <span class="st">&quot;/dev/disk/by-uuid/f73c53b7-ae6c-4240-89c3-511ad918edcc&quot;</span><span class="kw">;</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true"></a>      <span class="ex">fsType</span> = <span class="st">&quot;btrfs&quot;</span><span class="kw">;</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true"></a>      <span class="ex">options</span> = [ <span class="st">&quot;subvol=home&quot;</span> <span class="st">&quot;compress=zstd&quot;</span> <span class="st">&quot;noatime&quot;</span> ]<span class="kw">;</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true"></a>    <span class="kw">}</span>;</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true"></a></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true"></a>  <span class="ex">fileSystems.</span><span class="st">&quot;/nix&quot;</span> =</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true"></a>    <span class="kw">{</span> <span class="ex">device</span> = <span class="st">&quot;/dev/disk/by-uuid/f73c53b7-ae6c-4240-89c3-511ad918edcc&quot;</span><span class="kw">;</span></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true"></a>      <span class="ex">fsType</span> = <span class="st">&quot;btrfs&quot;</span><span class="kw">;</span></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true"></a>      <span class="ex">options</span> = [ <span class="st">&quot;subvol=nix&quot;</span> <span class="st">&quot;compress=zstd&quot;</span> <span class="st">&quot;noatime&quot;</span> ]<span class="kw">;</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true"></a>    <span class="kw">}</span>;</span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true"></a></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true"></a>  <span class="ex">fileSystems.</span><span class="st">&quot;/var/log&quot;</span> =</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true"></a>    <span class="kw">{</span> <span class="ex">device</span> = <span class="st">&quot;/dev/disk/by-uuid/f73c53b7-ae6c-4240-89c3-511ad918edcc&quot;</span><span class="kw">;</span></span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true"></a>      <span class="ex">fsType</span> = <span class="st">&quot;btrfs&quot;</span><span class="kw">;</span></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true"></a>      <span class="ex">options</span> = [ <span class="st">&quot;subvol=log&quot;</span> <span class="st">&quot;compress=zstd&quot;</span> <span class="st">&quot;noatime&quot;</span> ]<span class="kw">;</span></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true"></a>    <span class="kw">}</span>;</span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true"></a></span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true"></a>  <span class="ex">fileSystems.</span><span class="st">&quot;/persist&quot;</span> =</span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true"></a>    <span class="kw">{</span> <span class="ex">device</span> = <span class="st">&quot;/dev/disk/by-uuid/f73c53b7-ae6c-4240-89c3-511ad918edcc&quot;</span><span class="kw">;</span></span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true"></a>      <span class="ex">fsType</span> = <span class="st">&quot;btrfs&quot;</span><span class="kw">;</span></span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true"></a>      <span class="ex">options</span> = [ <span class="st">&quot;subvol=persist&quot;</span> <span class="st">&quot;compress=zstd&quot;</span> <span class="st">&quot;noatime&quot;</span> ]<span class="kw">;</span></span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true"></a>    <span class="kw">}</span>;</span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true"></a></span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true"></a>  <span class="ex">fileSystems.</span><span class="st">&quot;/boot&quot;</span> =</span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true"></a>    <span class="kw">{</span> <span class="ex">device</span> = <span class="st">&quot;/dev/disk/by-uuid/8CE7-3C76&quot;</span><span class="kw">;</span></span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true"></a>      <span class="ex">fsType</span> = <span class="st">&quot;vfat&quot;</span><span class="kw">;</span></span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true"></a>    <span class="kw">}</span>;</span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true"></a></span>
<span id="cb9-53"><a href="#cb9-53" aria-hidden="true"></a>  <span class="ex">swapDevices</span> =</span>
<span id="cb9-54"><a href="#cb9-54" aria-hidden="true"></a>    [ <span class="kw">{</span> <span class="ex">device</span> = <span class="st">&quot;/dev/disk/by-uuid/5b1b6659-14ab-497f-a788-5518c25e7ec8&quot;</span><span class="kw">;</span> <span class="kw">}</span></span>
<span id="cb9-55"><a href="#cb9-55" aria-hidden="true"></a>    ];</span>
<span id="cb9-56"><a href="#cb9-56" aria-hidden="true"></a></span>
<span id="cb9-57"><a href="#cb9-57" aria-hidden="true"></a>  <span class="ex">nix.maxJobs</span> = lib.mkDefault 8<span class="kw">;</span></span>
<span id="cb9-58"><a href="#cb9-58" aria-hidden="true"></a>  <span class="ex">powerManagement.cpuFreqGovernor</span> = lib.mkDefault <span class="st">&quot;powersave&quot;</span><span class="kw">;</span></span>
<span id="cb9-59"><a href="#cb9-59" aria-hidden="true"></a>  <span class="co"># High-DPI console</span></span>
<span id="cb9-60"><a href="#cb9-60" aria-hidden="true"></a>  <span class="ex">console.font</span> = lib.mkDefault <span class="st">&quot;</span><span class="va">${pkgs</span><span class="er">.terminus_font</span><span class="va">}</span><span class="st">/share/consolefonts/ter-u28n.psf.gz&quot;</span><span class="kw">;</span></span>
<span id="cb9-61"><a href="#cb9-61" aria-hidden="true"></a><span class="kw">}</span></span></code></pre></div>
<p>Make sure that this is what you want, and adjust options as necessary. Note that in order to correctly persist <code>/var/log</code>, the log subvolume needs to be mounted early enough in the boot process. To do this, we need to add <code>neededForBoot = true;</code> so the entry will look like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>  <span class="ex">fileSystems.</span><span class="st">&quot;/var/log&quot;</span> =</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>    <span class="kw">{</span> <span class="ex">device</span> = <span class="st">&quot;/dev/disk/by-uuid/f73c53b7-ae6c-4240-89c3-511ad918edcc&quot;</span><span class="kw">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>      <span class="ex">fsType</span> = <span class="st">&quot;btrfs&quot;</span><span class="kw">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>      <span class="ex">options</span> = [ <span class="st">&quot;subvol=log&quot;</span> <span class="st">&quot;compress=zstd&quot;</span> <span class="st">&quot;noatime&quot;</span> ]<span class="kw">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>      <span class="ex">neededForBoot</span> = true<span class="kw">;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>    <span class="kw">}</span>;</span></code></pre></div>
<p>Although it’s possible to customize <code>/etc/nixos/configuration.nix</code> at this point to set up all the things you need in one fell swoop, I recommend starting out with a reletively minimal config to make sure everything works ok. I went with something like this, with a user called <code>delta</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">{</span> <span class="ex">config</span>, pkgs, ... <span class="kw">}</span>:</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="kw">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>  <span class="ex">imports</span> =</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>    [ # <span class="ex">Include</span> the results of the hardware scan.</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>      <span class="ex">./hardware-configuration.nix</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>    ];</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>  <span class="ex">boot.kernelPackages</span> = pkgs.linuxPackages_latest<span class="kw">;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>  <span class="ex">boot.supportedFilesystems</span> = [ <span class="st">&quot;btrfs&quot;</span> ]<span class="kw">;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a>  <span class="ex">hardware.enableAllFirmware</span> = true<span class="kw">;</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a>  <span class="ex">nixpkgs.config.allowUnfree</span> = true<span class="kw">;</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a>  <span class="co"># Use the systemd-boot EFI boot loader.</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a>  <span class="ex">boot.loader.systemd-boot.enable</span> = true<span class="kw">;</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a>  <span class="ex">boot.loader.efi.canTouchEfiVariables</span> = true<span class="kw">;</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true"></a></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true"></a>  <span class="ex">networking.hostName</span> = <span class="st">&quot;apollo&quot;</span><span class="kw">;</span> # <span class="ex">Define</span> your hostname.</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true"></a>  <span class="ex">networking.networkmanager.enable</span> = true<span class="kw">;</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true"></a>  <span class="co"># Enable the X11 windowing system.</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true"></a>  <span class="ex">services.xserver.enable</span> = true<span class="kw">;</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true"></a></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true"></a>  <span class="co"># Enable the KDE Desktop Environment.</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true"></a>  <span class="ex">services.xserver.displayManager.sddm.enable</span> = true<span class="kw">;</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true"></a>  <span class="ex">services.xserver.desktopManager.plasma5.enable</span> = true<span class="kw">;</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true"></a></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true"></a>  <span class="co"># Define a user account. Don&#39;t forget to set a password with ‘passwd’.</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true"></a>  <span class="ex">users.users.delta</span> = {</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true"></a>    <span class="ex">isNormalUser</span> = true<span class="kw">;</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true"></a>    <span class="ex">extraGroups</span> = [ <span class="st">&quot;wheel&quot;</span> ]<span class="kw">;</span> # <span class="ex">Enable</span> ‘sudo’ for the user.</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true"></a>  <span class="kw">}</span>;</span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true"></a></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true"></a>  <span class="ex">system.stateVersion</span> = <span class="st">&quot;20.03&quot;</span><span class="kw">;</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true"></a>}</span></code></pre></div>
<p>Take a deep breath.</p>
<pre><code>nixos-install
reboot</code></pre>
<p>If all goes well, we’ll be prompted for the passphrase for <code>$DISK</code> entered earlier, then we’ll see the greeter for the KDE Desktop Environment. Swith to another tty with <code>Ctrl+Alt+F1</code>, login as root, <code>passwd delta</code> to set your password, and switch back to KDE with <code>Ctrl+Alt+F7</code>. Once you’re logged in, you can continue to tweak your NixOS configuration as you want. However, I generally recommend keeping enabled services at a minimum, and setting up opt-in state first.</p>
<h1 id="darling-erasure">Darling Erasure</h1>
<p>Now that we’re comfortable in our desktop environment of choice (mine is XMonad), we can move onto the opt-in state setup. First, we need to find out what state exists in the first place. Seeing what has changed since we took the blank snapshot seems like a good way to do this.</p>
<p>Taking a diff between the root subvolume and the root-blank subvolume (in btrfs, snapshots are just subvolumes) can be done with a script based off of the answers to <a href="https://serverfault.com/questions/399894/does-btrfs-have-an-efficient-way-to-compare-snapshots">this serverfault question</a>.</p>
<pre><code>#!/usr/bin/env bash
# fs-diff.sh
set -euo pipefail

OLD_TRANSID=$(sudo btrfs subvolume find-new /mnt/root-blank 9999999)
OLD_TRANSID=${OLD_TRANSID#transid marker was }

sudo btrfs subvolume find-new &quot;/mnt/root&quot; &quot;$OLD_TRANSID&quot; |
sed &#39;$d&#39; |
cut -f17- -d&#39; &#39; |
sort |
uniq |
while read path; do
  path=&quot;/$path&quot;
  if [ -L &quot;$path&quot; ]; then
    : # The path is a symbolic link, so is probably handled by NixOS already
  elif [ -d &quot;$path&quot; ]; then
    : # The path is a directory, ignore
  else
    echo &quot;$path&quot;
  fi
done</code></pre>
<p>Then, all it takes to find out which files now exist in the root subvolume is:</p>
<pre><code>sudo mkdir /mnt
sudo mount -o subvol=/ /dev/mapper/enc /mnt
./fs-diff.sh</code></pre>
<p>This may show a surprisingly small list of files, or possible something fairly lengthy, depending on your configuration. We’ll first tackle NetworkManager, so we don’t have to re-type passwords to Wi-Fi access points after every reboot. While <a href="https://grahamc.com/blog/erase-your-darlings">grahamc’s original blog post</a> suggests that simply persisting <code>/etc/NetworkManager/system-connections</code> by moving it to somewhere in <code>/persist</code> and creating a symlink is enough, this was not enough to get it to work on my XMonad setup. I ended up with something like this, symlinking a few files in <code>/var/lib/NetworkManager</code> as well.</p>
<pre><code>  environment.etc = {
    &quot;NetworkManager/system-connections&quot;.source = &quot;/persist/etc/NetworkManager/system-connections&quot;;
  };
  systemd.tmpfiles.rules = [
    &quot;L /var/lib/NetworkManager/secret_key - - - - /persist/var/lib/NetworkManager/secret_key&quot;
    &quot;L /var/lib/NetworkManager/seen-bssids - - - - /persist/var/lib/NetworkManager/seen-bssids&quot;
    &quot;L /var/lib/NetworkManager/timestamps - - - - /persist/var/lib/NetworkManager/timestamps&quot;
  ];</code></pre>
<p>Now you might have noticed that the NixOS configuration itself lives in <code>/etc/nixos/</code>, which will be deleted if left there. After adding a few things, I ended up with a configuration like this.</p>
<pre><code> environment.etc = {
    nixos.source = &quot;/persist/etc/nixos&quot;;
    &quot;NetworkManager/system-connections&quot;.source = &quot;/persist/etc/NetworkManager/system-connections&quot;;
    adjtime.source = &quot;/persist/etc/adjtime&quot;;
    NIXOS.source = &quot;/persist/etc/NIXOS&quot;;
  };
  systemd.tmpfiles.rules = [
    &quot;L /var/lib/NetworkManager/secret_key - - - - /persist/var/lib/NetworkManager/secret_key&quot;
    &quot;L /var/lib/NetworkManager/seen-bssids - - - - /persist/var/lib/NetworkManager/seen-bssids&quot;
    &quot;L /var/lib/NetworkManager/timestamps - - - - /persist/var/lib/NetworkManager/timestamps&quot;
  ];
  security.sudo.extraConfig = &#39;&#39;
    # rollback results in sudo lectures after each reboot
    Defaults lecture = never
  &#39;&#39;;</code></pre>
<p>Rolling back the root subvolume is a little bit involved when compared to zfs, but can be achieved with this config.</p>
<pre><code>  # Note `lib.mkBefore` is used instead of `lib.mkAfter` here.
  boot.initrd.postDeviceCommands = pkgs.lib.mkBefore &#39;&#39;
    mkdir -p /mnt

    # We first mount the btrfs root to /mnt
    # so we can manipulate btrfs subvolumes.
    mount -o subvol=/ /dev/mapper/enc /mnt

    # While we&#39;re tempted to just delete /root and create
    # a new snapshot from /root-blank, /root is already
    # populated at this point with a number of subvolumes,
    # which makes `btrfs subvolume delete` fail.
    # So, we remove them first.
    #
    # /root contains subvolumes:
    # - /root/var/lib/portables
    # - /root/var/lib/machines
    #
    # I suspect these are related to systemd-nspawn, but
    # since I don&#39;t use it I&#39;m not 100% sure.
    # Anyhow, deleting these subvolumes hasn&#39;t resulted
    # in any issues so far, except for fairly
    # benign-looking errors from systemd-tmpfiles.
    btrfs subvolume list -o /mnt/root |
    cut -f9 -d&#39; &#39; |
    while read subvolume; do
      echo &quot;deleting /$subvolume subvolume...&quot;
      btrfs subvolume delete &quot;/mnt/$subvolume&quot;
    done &amp;&amp;
    echo &quot;deleting /root subvolume...&quot; &amp;&amp;
    btrfs subvolume delete /mnt/root

    echo &quot;restoring blank /root subvolume...&quot;
    btrfs subvolume snapshot /mnt/root-blank /mnt/root

    # Once we&#39;re done rolling back to a blank snapshot,
    # we can unmount /mnt and continue on the boot process.
    umount /mnt
  &#39;&#39;;</code></pre>
<p>While NixOS will take care of creating the specified symlinks, we need to move the relevant file and directories to where the symlinks are pointing at after running <code>sudo nixos-rebuild boot</code> and before rebooting.</p>
<pre><code>sudo nixos-rebuild boot

sudo mkdir -p /persist/etc/NetworkManager
sudo cp -r {,/persist}/etc/NetworkManager/system-connections
sudo mkdir -p /persist/var/lib/NetworkManager
sudo cp /var/lib/NetworkManager/{secret_key,seen-bssids,timestamps} /persist/var/lib/NetworkManager/

sudo cp {,/persist}/etc/nixos
sudo cp {,/persist}/etc/adjtime
sudo cp {,/persist}/etc/NIXOS</code></pre>
<p>Before rebooting, make sure that your user credentials are appropriately handled. Be especially careful<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> when setting <code>users.mutableUsers</code> to false and using <code>users.extraUsers.&lt;name?&gt;.passwordFile</code>, as these settings are some of the few in NixOS which can lock you out across NixOS configurations and require non-trivial recovery work or a reinstall. If you want declerative user management, I recommend using <code>users.extraUsers.&lt;name?&gt;.hashedPasswords</code>, but this has it’s own downsides as well.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<p>Take another deep breath.</p>
<pre><code>reboot</code></pre>
<p>If something goes wrong and <code>/mnt/root</code> isn’t deleted, <code>btrfs subvolume snapshot /mnt/root-blank /mnt/root</code> will just create a snapshot under <code>/mnt/root</code>, so a quick hack to check if rolling back failed without consulting <code>journalctl -b</code> is to see if <code>/mnt/root/root-blank</code> exists.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<h1 id="adding-nixos-services-case-study-docker-and-lxd">Adding NixOS Services Case Study (Docker and LXD)</h1>
<p>As much as Nix and NixOS are attractive for everyday use, sometimes the time it takes to get some language or package running on NixOS just doesn’t seem worth it. That’s when container runtimes like Docker and LXD can help. These tools can act as an escape hatch to get some software working quikly on your machine.</p>
<p>Here, we’ll go through the workflow for getting NixOS services to work with opt-in state, with Docker and LXD as examples.</p>
<p>First, let’s get Docker and LXD running to inspect what kind of state they have. Thanks to NixOS, this is a just a few lines of configuration.</p>
<pre><code>  virtualisation = {
     docker.enable = true;
    lxd = {
      enable = true;
      recommendedSysctlSettings = true;
    };
  };</code></pre>
<pre><code>sudo nixos-rebuild switch</code></pre>
<p>This will install, set up, and start both Docker and LXD on our machine. With <code>fs-diff.sh</code> we can see a few relevant files and directories show up.</p>
<pre><code>/etc/docker/key.json
...
/var/lib/docker/...
/var/lib/lxd/...</code></pre>
<p>Some quick googling tells us that <code>/etc/docker/key.json</code> is generated on every boot, so it seems like we don’t need to keep this around. On the other hand, <code>/var/lib/docker</code> and <code>/var/lib/lxd</code> seem important, so let’s adjust our config accordingly.</p>
<pre><code>  systemd.tmpfiles.rules = [
    &quot;L /var/lib/NetworkManager/secret_key - - - - /persist/var/lib/NetworkManager/secret_key&quot;
    &quot;L /var/lib/NetworkManager/seen-bssids - - - - /persist/var/lib/NetworkManager/seen-bssids&quot;
    &quot;L /var/lib/NetworkManager/timestamps - - - - /persist/var/lib/NetworkManager/timestamps&quot;
    &quot;L /var/lib/lxd - - - - /persist/var/lib/lxd&quot;
    &quot;L /var/lib/docker - - - - /persist/var/lib/docker&quot;
  ];</code></pre>
<p>Now, stop the two services and copy over the directories.</p>
<pre><code>sudo mkdir -p /persist/var/lib/

sudo systemctl stop lxd
sudo cp -r {,/persist}/var/lib/lxd

sudo systemctl stop docker
sudo cp -r {,/persist}/var/lib/docker

sudo nixos-rebuild boot
reboot</code></pre>
<p>If all goes well, running the <code>fs-diff.sh</code> after reboot shouldn’t show persisted directories <code>/var/lib/lxd</code> and <code>/var/lib/docker</code> since they should be symlinks which are created during the boot process.</p>
<p>Docker should work without any problems at this point, but we LXD needs some additional configuration. LXD requires a storage pool to operate, so we create a subvolume for LXD, and mount it in <code>/persist</code>.</p>
<pre><code>sudo mount -o subvol=/ /mnt
sudo btrfs subvolume create /mnt/lxd
sudo umount /mnt
sudo mkdir /persist/lxd
sudo mount -o subvol=lxd /dev/mapper/enc /persist/lxd</code></pre>
<p>Once the subvolume is ready, we run <code>lxd init</code> and answer the questions in the following manner.</p>
<pre><code>$ lxd init
Would you like to use LXD clustering? (yes/no) [default=no]: no
Do you want to configure a new storage pool? (yes/no) [default=yes]:
Name of the new storage pool [default=default]:
Name of the storage backend to use (btrfs, dir, lvm) [default=btrfs]:
Would you like to create a new btrfs subvolume under /var/lib/lxd? (yes/no) [default=yes]: no
Create a new BTRFS pool? (yes/no) [default=yes]: no
Name of the existing BTRFS pool or dataset: /persist/lxd
Would you like to connect to a MAAS server? (yes/no) [default=no]:
Would you like to create a new local network bridge? (yes/no) [default=yes]:
What should the new bridge be called? [default=lxdbr0]:
What IPv4 address should be used? (CIDR subnet notation, “auto” or “none”) [default=auto]:
What IPv6 address should be used? (CIDR subnet notation, “auto” or “none”) [default=auto]:
Would you like LXD to be available over the network? (yes/no) [default=no]:
Would you like stale cached images to be updated automatically? (yes/no) [default=yes]
Would you like a YAML &quot;lxd init&quot; preseed to be printed? (yes/no) [default=no]:</code></pre>
<p>Remember to add the relevant information to <code>/etc/nixos/hardware-configuration.nix</code> so NixOS will mount the subvolume where LXD expects (i.e. <code>/persist/lxd</code>).</p>
<pre><code>  fileSystems.&quot;/persist/lxd&quot; =
    { device = &quot;/dev/disk/by-uuid/f73c53b7-ae6c-4240-89c3-511ad918edcc&quot;;
      fsType = &quot;btrfs&quot;;
      options = [ &quot;subvol=lxd&quot; &quot;compress=zstd&quot; &quot;noatime&quot; ];
    };</code></pre>
<p><small> Thanks to cannorin and __pandaman64__ for comments and suggestions. </small></p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>When using a Windows or macOS laptop, I find myself reinstalling the OS every so often to restore the machine to a clean state. Why go through this trouble if you can get your OS to do this on every boot?<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Sadly, we stop short of FDE and settle for only encrypting the btrfs volume, as encrypting <code>/boot</code> seems <a href="https://elvishjerricco.github.io/2018/12/06/encrypted-boot-on-zfs-with-nixos.html">much more complicated</a> than I’m willing to experiment with. It’s unfortunate that desktop Linux security severely lags behind smartphones, where FDE is the norm rather than the exception, for example.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Note that I’m creating a swap partition despite having 32GB of RAM. Contrary to popular belief, you should still create swap partitions on systems with “enough RAM”. See this blog post for details: <a href="https://chrisdown.name/2018/01/02/in-defence-of-swap.html">In defence of swap: common misconceptions</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p><a href="https://github.com/NixOS/nixpkgs/issues/4990#issuecomment-63238644">You may need to add <code>neededForBoot = true;</code> to <code>/persist</code></a>, but I haven’t verified this first-hand.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>Using <code>hashedPasswords</code> has two drawbacks off the top of my head:</p>
<ul>
<li>Since your configuration is kept in the Nix store, other users can read your hashed password and attempt to crack it. Note this does not happen when <code>users.mutableUsers = false;</code> since <code>/etc/shadow</code> is only root-readable.</li>
<li>Putting your configuration.nix in a public repository has similar problems. I feel this is a bigger problem, since you can no longer just <code>git clone https://github.com/user/dotfiles-repo</code> which may somewhat complicate your initial setup process.</li>
</ul>
<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></li>
<li id="fn6" role="doc-endnote"><p>Something like <code>[ -d /root-blank ] &amp;&amp; notify-send -u critical "opt-in state" "rollback failed"</code> would be nice to run after logging in.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<a href="../index.html">index</a>
<script src="https://utteranc.es/client.js" repo="mt-caret/blog" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
</article>
</body>
</html>
